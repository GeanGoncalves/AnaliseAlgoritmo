# Ordena√ß√£o em Tempo Linear

Bem-vindo ao reposit√≥rio do projeto de Ordena√ß√£o em Tempo Linear! Este projeto explora algoritmos de ordena√ß√£o que podem operar em tempo linear, superando o limite de Œò(n*log(n)) imposto pelos algoritmos de ordena√ß√£o baseados em compara√ß√£o. Utilizaremos os algoritmos Counting Sort e Radix Sort para demonstrar essas t√©cnicas.

üìö **Conte√∫do**
1. **Algoritmos de Ordena√ß√£o**
   - **Counting Sort:** Ordena inteiros em um intervalo limitado, sem realizar compara√ß√µes diretas entre elementos.
   - **Radix Sort:** Ordena n√∫meros com m√∫ltiplos d√≠gitos, utilizando Counting Sort de forma iterativa para cada d√≠gito.

2. **An√°lise de Complexidade**
   - **Counting Sort:** Executa em Œò(n + k), onde `n` √© o n√∫mero de elementos e `k` √© o valor m√°ximo do intervalo.
   - **Radix Sort:** Executa em Œò(d*(n + k)), onde `d` √© o n√∫mero de d√≠gitos e `k` √© o intervalo de valores poss√≠veis para cada d√≠gito.

3. **Implementa√ß√£o e Testes**
   - **Counting Sort:** Implementa√ß√£o e compara√ß√£o com algoritmos baseados em compara√ß√£o como Insertion Sort e Quick Sort.
   - **Radix Sort:** Aplica√ß√£o sobre n√∫meros de v√°rios d√≠gitos e compara√ß√£o com Counting Sort em termos de efici√™ncia.

üöÄ **Objetivo**
Este projeto visa explorar e implementar algoritmos de ordena√ß√£o que operam em tempo linear, demonstrando como esses algoritmos podem superar as limita√ß√µes dos m√©todos baseados em compara√ß√£o. O objetivo √© entender a aplicabilidade e efici√™ncia desses algoritmos em diferentes contextos e comparar seus desempenhos com m√©todos tradicionais.

üõ† **Tecnologias Utilizadas**
- C++ para desenvolvimento dos algoritmos
- Bibliotecas padr√£o como `<vector>`, `<iostream>`, `<fstream>`, e `<ctime>` para a implementa√ß√£o
- Planilha eletr√¥nica (Microsoft Excel ou similar) para an√°lise e visualiza√ß√£o de dados

